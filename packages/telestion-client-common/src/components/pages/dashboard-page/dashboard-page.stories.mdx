import {
	Meta,
	Story,
	Canvas,
	ArgsTable,
	Description
} from '@storybook/addon-docs/blocks';
import {
	Pages,
	TelestionClient,
	useAuth,
	useEventBus
} from '@wuespace/telestion-client-core';
import { MemoryRouter, Route } from 'react-router-dom';
import { useUserConfig } from '../../../hooks';
import { DashboardPage } from './dashboard-page';
import { CommonWrapper } from '../../common-wrapper';
import { DashboardPicker } from '../../header';

<Meta
	title="Common/Pages/Dashboard Page"
	component={DashboardPage}
	decorators={[
		Story => {
			return (
				<TelestionClient>
					<MemoryRouter initialEntries={['/dashboard/0']} initialIndex={0}>
						<Route path={'/dashboard/:id'}>
							<CommonWrapper
								widgets={[
									{ name: 'widget-1', Widget: () => <h1>Hello world 1</h1> },
									{ name: 'widget-2', Widget: () => <h1>Hello world 2</h1> },
									{ name: 'widget-3', Widget: () => <h1>Hello world 3</h1> }
								]}
							>
								{Story()}
							</CommonWrapper>
						</Route>
					</MemoryRouter>
				</TelestionClient>
			);
		}
	]}
	argTypes={{
		dashboard: {
			control: 'object'
		}
	}}
/>

# Dashboard Page

<Description of={DashboardPage} />

## Importing

```tsx
import { DashboardPage } from '@wuespace/telestion-client-common';
```

## Examples

For the following examples, we'll pass a basic set of widgets to the `CommonWrapper`:

```tsx
const widgets = [
	{ name: 'widget-1', Widget: () => <h1>Hello world 1</h1> },
	{ name: 'widget-2', Widget: () => <h1>Hello world 2</h1> },
	{ name: 'widget-3', Widget: () => <h1>Hello world 3</h1> }
];
```

### Basic Dashboard

Let's take a look at a basic dashboard page example. All widgets exist and everything looks good.

Our dashboard is defined like this:

```tsx
import { Dashboard } from '@wuespace/telestion-client-types';

const dashboard: Dashboard = {
	rows: 4,
	columns: 4,
	title: 'ABC',
	widgets: [
		{
			width: 2,
			height: 2,
			title: 'Hello world',
			widgetName: 'widget-1'
		},
		{
			width: 2,
			height: 2,
			title: 'Hello world 2',
			widgetName: 'widget-2'
		},
		{
			width: 4,
			height: 2,
			title: 'Hello world 3',
			widgetName: 'widget-3'
		}
	]
};
```

When rendering to matching `DashboardPage`, it looks like this:

<Canvas>
	<Story
		name="Basic Dashboard"
		inline={false}
		height={'512px'}
		args={{
			dashboard: {
				rows: 4,
				columns: 4,
				title: 'ABC',
				widgets: [
					{
						width: 2,
						height: 2,
						title: 'Hello world',
						widgetName: 'widget-1'
					},
					{
						width: 2,
						height: 2,
						title: 'Hello world 2',
						widgetName: 'widget-2'
					},
					{
						width: 4,
						height: 2,
						title: 'Hello world 3',
						widgetName: 'widget-3'
					}
				]
			}
		}}
	>
		{args => {
			useAuth.setState({ auth: { username: 'alice' } });
			const { eventBus } = useEventBus.getState();
			if (!eventBus) useEventBus.setState({ eventBus: {} });
			useUserConfig.setState({
				userConfig: {
					alice: {
						dashboards: [args.dashboard]
					}
				}
			});
			return <DashboardPage />;
		}}
	</Story>
</Canvas>

### Missing widgets

Let's modify our dashboard so that some widgets we want to use don't exist (`'non-existent-widget'` was never declared
in the widget database above).

```tsx
import { Dashboard } from '@wuespace/telestion-client-types';

const dashboard: Dashboard = {
	rows: 4,
	columns: 4,
	title: 'ABC',
	widgets: [
		{
			width: 2,
			height: 2,
			title: 'Hello world',
			widgetName: 'non-existent-widget'
		},
		{
			width: 2,
			height: 2,
			title: 'Hello world 2',
			widgetName: 'widget-2'
		},
		{
			width: 4,
			height: 2,
			title: 'Hello world 3',
			widgetName: 'non-existent-widget'
		}
	]
};
```

With these changes, you can see that Telestion Client will still render the dashboard, and render a suitable error
message in place of the widget:

<Canvas>
	<Story
		name="Missing widgets"
		inline={false}
		height={'512px'}
		args={{
			dashboard: {
				rows: 4,
				columns: 4,
				title: 'ABC',
				widgets: [
					{
						width: 2,
						height: 2,
						title: 'Hello world',
						widgetName: 'non-existent-widget'
					},
					{
						width: 2,
						height: 2,
						title: 'Hello world 2',
						widgetName: 'widget-2'
					},
					{
						width: 4,
						height: 2,
						title: 'Hello world 3',
						widgetName: 'non-existent-widget'
					}
				]
			}
		}}
	>
		{args => {
			useAuth.setState({ auth: { username: 'alice' } });
			const { eventBus } = useEventBus.getState();
			if (!eventBus) useEventBus.setState({ eventBus: {} });
			useUserConfig.setState({
				userConfig: {
					alice: {
						dashboards: [args.dashboard]
					}
				}
			});
			return <DashboardPage />;
		}}
	</Story>
</Canvas>

### No event bus instance

The dashboard page also checks, if there is an event bus instance where the widgets can subscribe to.

The page waits, if the event bus currently does not exist.
This prevents widgets from crashing:

<Canvas>
	<Story
		name="No event bus instance"
		inline={false}
		height={'512px'}
		args={{
			dashboard: {
				rows: 4,
				columns: 4,
				title: 'ABC',
				widgets: [
					{
						width: 2,
						height: 2,
						title: 'Hello world',
						widgetName: 'widget-1'
					},
					{
						width: 2,
						height: 2,
						title: 'Hello world 2',
						widgetName: 'widget-2'
					},
					{
						width: 4,
						height: 2,
						title: 'Hello world 3',
						widgetName: 'widget-3'
					}
				]
			}
		}}
	>
		{args => {
			useAuth.setState({ auth: { username: 'alice' } });
			const { eventBus } = useEventBus.getState();
			if (eventBus) useEventBus.setState({ eventBus: null });
			useUserConfig.setState({
				userConfig: {
					alice: {
						dashboards: [args.dashboard]
					}
				}
			});
			return <DashboardPage />;
		}}
	</Story>
</Canvas>

## Properties

<ArgsTable of={DashboardPage} />
